var documenterSearchIndex = {"docs":
[{"location":"guide/#Guide","page":"Guide","title":"Guide","text":"This guide assumes familiarity with Documenter.jl. It covers how to write documentation in AsciiDoc.","category":"section"},{"location":"guide/#Conversion-Workflow","page":"Guide","title":"Conversion Workflow","text":"Documenter.jl works on Markdown files. To use AsciiDoc, you must convert your .adoc files to .md before makedocs runs.","category":"section"},{"location":"guide/#In-docs/make.jl","page":"Guide","title":"In docs/make.jl","text":"using Documenter\nusing AsciiDocumenter\nusing MyPackage\n\n# 1. Convert AsciiDoc -> Markdown\nfor (root, dirs, files) in walkdir(joinpath(@__DIR__, \"src\"))\n    for file in files\n        if endswith(file, \".adoc\")\n            path = joinpath(root, file)\n            println(\"Converting $path...\")\n            \n            # Read AsciiDoc\n            adoc = read(path, String)\n            \n            # Parse and Convert\n            doc = AsciiDocumenter.parse(adoc)\n            md = AsciiDocumenter.to_markdown(doc)\n            \n            # Write Markdown file next to source\n            write(replace(path, \".adoc\" => \".md\"), md)\n        end\n    end\nend\n\n# 2. Run makedocs with .md files\nmakedocs(\n    sitename = \"MyPackage.jl\",\n    modules = [MyPackage],\n    pages = [\n        \"Home\" => \"index.md\",\n        # Note: Refer to the generated .md files, not .adoc\n        \"Guide\" => \"guide.md\", \n        \"API\" => \"api.md\"\n    ]\n)","category":"section"},{"location":"guide/#Writing-for-Documenter","page":"Guide","title":"Writing for Documenter","text":"AsciiDocumenter.jl is designed to act as a transparent bridge. You write AsciiDoc, and it generates the Markdown signals that Documenter expects.","category":"section"},{"location":"guide/#Cross-References","page":"Guide","title":"Cross-References","text":"Do not use standard <<id>> internal links for cross-page references. Use the link: macro with @ref.\n\nCorrect: link:@ref[See the Guide]\nCorrect: link:@ref#section-id[See Section]\nIncorrect: <<section-id, See Section>> (Only works on the same page)","category":"section"},{"location":"guide/#Math","page":"Guide","title":"Math","text":"Use stem blocks.\n\nInline: stem:[x^2]\nDisplay:\n[source,asciidoc]\n\n[stem]\n++++\nx^2\n++++","category":"section"},{"location":"guide/#Docstrings","page":"Guide","title":"Docstrings","text":"Use [source,@docs] blocks.\n\n[source,@docs]\n\nMyPackage.my_function\n\n","category":"section"},{"location":"guide/#File-Structure","page":"Guide","title":"File Structure","text":"Your docs/src folder can look exactly like a standard Documenter project, just with .adoc files.\n\ndocs/\n├── make.jl\n├── Project.toml\n└── src/\n    ├── index.adoc\n    ├── guide.adoc\n    └── api.adoc\n\nThe conversion script will generate sibling .md files (e.g., index.md) which Documenter will then process.","category":"section"},{"location":"reference/#API-Reference","page":"API Reference","title":"API Reference","text":"Complete reference for all exported types and functions in AsciiDocumenter.jl.","category":"section"},{"location":"reference/#Parsing-Functions","page":"API Reference","title":"Parsing Functions","text":"","category":"section"},{"location":"reference/#Conversion-Functions","page":"API Reference","title":"Conversion Functions","text":"","category":"section"},{"location":"reference/#Backend-Functions","page":"API Reference","title":"Backend Functions","text":"","category":"section"},{"location":"reference/#HTML-Backend","page":"API Reference","title":"HTML Backend","text":"","category":"section"},{"location":"reference/#LaTeX-Backend","page":"API Reference","title":"LaTeX Backend","text":"","category":"section"},{"location":"reference/#MarkdownAST-Integration","page":"API Reference","title":"MarkdownAST Integration","text":"","category":"section"},{"location":"reference/#Document-Structure","page":"API Reference","title":"Document Structure","text":"","category":"section"},{"location":"reference/#Block-Level-Nodes","page":"API Reference","title":"Block-Level Nodes","text":"","category":"section"},{"location":"reference/#List-Nodes","page":"API Reference","title":"List Nodes","text":"","category":"section"},{"location":"reference/#Table-Nodes","page":"API Reference","title":"Table Nodes","text":"","category":"section"},{"location":"reference/#Inline-Nodes","page":"API Reference","title":"Inline Nodes","text":"","category":"section"},{"location":"reference/#AsciiDocumenter.parse","page":"API Reference","title":"AsciiDocumenter.parse","text":"parse(text::AbstractString; base_path::AbstractString=pwd()) -> Document\n\nParse AsciiDoc text into a Document AST.\n\nThis is a convenience wrapper around Base.parse(Document, text).\n\nArguments\n\ntext: The AsciiDoc source text\nbase_path: Directory for resolving include directives (default: current directory)\n\nExample\n\ndoc = parse(\"\"\"\n= My Title\n\nThis is a paragraph.\n\"\"\")\n\n# With include support\ndoc = parse(\"include::other.adoc[]\"; base_path=\"/path/to/docs\")\n\n\n\n\n\n","category":"function"},{"location":"reference/#AsciiDocumenter.parse_asciidoc","page":"API Reference","title":"AsciiDocumenter.parse_asciidoc","text":"parse_asciidoc(text::String; base_path::String=pwd()) -> Document\n\nParse an AsciiDoc document into an AST.\n\nArguments\n\ntext: The AsciiDoc source text\nbase_path: Directory for resolving include directives (default: current directory)\n\n\n\n\n\n","category":"function"},{"location":"reference/#AsciiDocumenter.parse_asciidoc_file","page":"API Reference","title":"AsciiDocumenter.parse_asciidoc_file","text":"parse_asciidoc_file(filepath::String) -> Document\n\nParse an AsciiDoc file into an AST. Automatically sets base_path for includes.\n\n\n\n\n\n","category":"function"},{"location":"reference/#AsciiDocumenter.parse_inline","page":"API Reference","title":"AsciiDocumenter.parse_inline","text":"parse_inline(text::AbstractString) -> Vector{InlineNode}\n\nParse inline formatting within text using a Regex-based approach.\n\n\n\n\n\nparse_inline(text::AbstractString, attributes::Dict{String,String}) -> Vector{InlineNode}\n\nParse inline formatting within text using a Regex-based approach.\n\nOptionally substitutes attribute references ({name}) with their values.\n\n\n\n\n\n","category":"function"},{"location":"reference/#Base.convert-Tuple{Type{AsciiDocumenter.LaTeXBackend}, Document}","page":"API Reference","title":"Base.convert","text":"convert(::Type{LaTeX}, doc::Document) -> String\n\nConvert a Document AST to LaTeX.\n\nExample\n\ndoc = parse(\"= Title\\n\\nParagraph\")\nlatex = convert(LaTeX, doc)\n\n\n\n\n\n","category":"method"},{"location":"reference/#Base.convert-Tuple{Type{AsciiDocumenter.HTMLBackend}, Document}","page":"API Reference","title":"Base.convert","text":"convert(::Type{HTML}, doc::Document; standalone=false) -> String\n\nConvert a Document AST to HTML.\n\nSet standalone=true to generate a complete HTML document with CSS.\n\nExample\n\ndoc = parse(\"= Title\\n\\nParagraph\")\nhtml = convert(HTML, doc)\nhtml_standalone = convert(HTML, doc, standalone=true)\n\n\n\n\n\n","category":"method"},{"location":"reference/#AsciiDocumenter.asciidoc_to_html","page":"API Reference","title":"AsciiDocumenter.asciidoc_to_html","text":"asciidoc_to_html(text::AbstractString; standalone=false) -> String\n\nParse AsciiDoc text and convert directly to HTML.\n\nExample\n\nhtml = asciidoc_to_html(\"\"\"\n= My Document\n\nSome *bold* text.\n\"\"\", standalone=true)\n\n\n\n\n\n","category":"function"},{"location":"reference/#AsciiDocumenter.asciidoc_to_latex","page":"API Reference","title":"AsciiDocumenter.asciidoc_to_latex","text":"asciidoc_to_latex(text::AbstractString) -> String\n\nParse AsciiDoc text and convert directly to LaTeX.\n\nExample\n\nlatex = asciidoc_to_latex(\"\"\"\n= My Document\n\nSome *bold* text.\n\"\"\")\n\n\n\n\n\n","category":"function"},{"location":"reference/#AsciiDocumenter.to_html","page":"API Reference","title":"AsciiDocumenter.to_html","text":"to_html(io::IO, doc::Document; standalone=false) -> Nothing\n\nConvert an AsciiDoc document to HTML, writing to the provided IO stream.\n\nIf standalone=true, wraps the output in a complete HTML document.\n\n\n\n\n\nto_html(io::IO, node::Header) -> Nothing\n\nConvert a header to HTML heading tag, writing to IO.\n\n\n\n\n\nto_html(io::IO, node::Paragraph) -> Nothing\n\nConvert a paragraph to HTML, writing to IO.\n\n\n\n\n\nto_html(io::IO, node::CodeBlock) -> Nothing\n\nConvert a code block to HTML, writing to IO.\n\nSupports:\n\nlinenums attribute for displaying line numbers\nCallout markers <1> and callout definitions\n\n\n\n\n\nto_html(io::IO, node::BlockQuote) -> Nothing\n\nConvert a block quote to HTML, writing to IO.\n\n\n\n\n\nto_html(io::IO, node::Admonition) -> Nothing\n\nConvert an admonition to HTML, writing to IO.\n\nProduces semantic HTML with appropriate classes for styling. Uses custom title if provided, otherwise defaults to capitalized type.\n\n\n\n\n\nto_html(io::IO, node::UnorderedList) -> Nothing\n\nConvert an unordered list to HTML, writing to IO.\n\n\n\n\n\nto_html(io::IO, node::OrderedList) -> Nothing\n\nConvert an ordered list to HTML, writing to IO.\n\nSupports start attribute for custom starting number.\n\n\n\n\n\nto_html(io::IO, node::DefinitionList) -> Nothing\n\nConvert a definition list to HTML, writing to IO.\n\n\n\n\n\nto_html(io::IO, node::Table) -> Nothing\n\nConvert a table to HTML, writing to IO.\n\nSupports:\n\ncols attribute for column alignment (< left, ^ center, > right)\n\nTable header handling:\n\nIf a row is explicitly marked as header (is_header=true), it renders as <th>\nOtherwise, the first row is treated as a header by default\nThis provides sensible defaults while respecting explicit header markers from [%header] or [options=\"header\"]\n\n\n\n\n\nto_html(io::IO, node::HorizontalRule) -> Nothing\n\nConvert a horizontal rule to HTML, writing to IO.\n\n\n\n\n\nto_html(io::IO, node::Text) -> Nothing\n\nConvert text node to HTML (with escaping), writing to IO.\n\n\n\n\n\nto_html(io::IO, node::Bold) -> Nothing\n\nConvert bold text to HTML, writing to IO.\n\n\n\n\n\nto_html(io::IO, node::Italic) -> Nothing\n\nConvert italic text to HTML, writing to IO.\n\n\n\n\n\nto_html(io::IO, node::Monospace) -> Nothing\n\nConvert monospace text to HTML, writing to IO.\n\n\n\n\n\nto_html(io::IO, node::Subscript) -> Nothing\n\nConvert subscript to HTML, writing to IO.\n\n\n\n\n\nto_html(io::IO, node::Superscript) -> Nothing\n\nConvert superscript to HTML, writing to IO.\n\n\n\n\n\nto_html(io::IO, node::Link) -> Nothing\n\nConvert a link to HTML, writing to IO.\n\n\n\n\n\nto_html(io::IO, node::Image) -> Nothing\n\nConvert an image to HTML, writing to IO.\n\n\n\n\n\nto_html(io::IO, node::CrossRef) -> Nothing\n\nConvert a cross-reference to HTML, writing to IO.\n\n\n\n\n\nto_html(io::IO, node::LineBreak) -> Nothing\n\nConvert a line break to HTML, writing to IO.\n\n\n\n\n\nto_html(io::IO, node::PassthroughBlock) -> Nothing\n\nConvert a passthrough block to HTML, writing to IO.\n\nIf the block has a \"stem\" style attribute, wraps it as display math for MathJax/KaTeX. Otherwise, outputs raw content (useful for embedding raw HTML).\n\n\n\n\n\nto_html(io::IO, node::InlineMath) -> Nothing\n\nConvert inline math to HTML, writing to IO.\n\nWraps content for MathJax/KaTeX using inline math delimiters.\n\n\n\n\n\nto_html(doc::Document; standalone=false) -> String\n\nConvert an AsciiDoc document to HTML string.\n\nThis is a convenience wrapper that creates an IOBuffer internally. For streaming output, use to_html(io::IO, doc::Document) instead.\n\n\n\n\n\nto_html(node::Union{BlockNode,InlineNode}) -> String\n\nConvert any AST node to HTML string.\n\nThis is a convenience wrapper that creates an IOBuffer internally. For streaming output, use to_html(io::IO, node) instead.\n\n\n\n\n\n","category":"function"},{"location":"reference/#AsciiDocumenter.to_latex","page":"API Reference","title":"AsciiDocumenter.to_latex","text":"to_latex(io::IO, doc::Document) -> Nothing\n\nConvert an AsciiDoc document to LaTeX, writing to the provided IO stream.\n\n\n\n\n\nto_latex(io::IO, node::Header) -> Nothing\n\nConvert a header to LaTeX section command, writing to IO.\n\nHeader level mapping:\n\nLevel 0, 1 → \\section\nLevel 2 → \\subsection\nLevel 3 → \\subsubsection\nLevel 4 → \\paragraph\nLevel 5+ → \\subparagraph\n\nNote: \\chapter is not used as AsciiDoc documents typically don't have document-level chapters.\n\n\n\n\n\nto_latex(io::IO, node::Paragraph) -> Nothing\n\nConvert a paragraph to LaTeX, writing to IO.\n\n\n\n\n\nto_latex(io::IO, node::CodeBlock) -> Nothing\n\nConvert a code block to LaTeX using listings or verbatim, writing to IO.\n\nSupports:\n\nlinenums attribute for displaying line numbers\nCallout definitions rendered as a description list\n\n\n\n\n\nto_latex(io::IO, node::BlockQuote) -> Nothing\n\nConvert a block quote to LaTeX quotation environment, writing to IO.\n\n\n\n\n\nto_latex(io::IO, node::Admonition) -> Nothing\n\nConvert an admonition to LaTeX, writing to IO.\n\nUses a simple boxed format. For better styling, consider using packages like tcolorbox in your document preamble. Uses custom title if provided, otherwise defaults to capitalized type.\n\n\n\n\n\nto_latex(io::IO, node::UnorderedList) -> Nothing\n\nConvert an unordered list to LaTeX itemize environment, writing to IO.\n\n\n\n\n\nto_latex(io::IO, node::OrderedList) -> Nothing\n\nConvert an ordered list to LaTeX enumerate environment, writing to IO.\n\nSupports start attribute for custom starting number.\n\n\n\n\n\nto_latex(io::IO, node::DefinitionList) -> Nothing\n\nConvert a definition list to LaTeX description environment, writing to IO.\n\n\n\n\n\nto_latex(io::IO, node::Table) -> Nothing\n\nConvert a table to LaTeX tabular environment, writing to IO.\n\nSupports cols attribute for column alignment (< left, ^ center, > right).\n\n\n\n\n\nto_latex(io::IO, node::HorizontalRule) -> Nothing\n\nConvert a horizontal rule to LaTeX, writing to IO.\n\n\n\n\n\nto_latex(io::IO, node::Text) -> Nothing\n\nConvert text node to LaTeX (with escaping), writing to IO.\n\n\n\n\n\nto_latex(io::IO, node::Bold) -> Nothing\n\nConvert bold text to LaTeX, writing to IO.\n\n\n\n\n\nto_latex(io::IO, node::Italic) -> Nothing\n\nConvert italic text to LaTeX, writing to IO.\n\n\n\n\n\nto_latex(io::IO, node::Monospace) -> Nothing\n\nConvert monospace text to LaTeX, writing to IO.\n\n\n\n\n\nto_latex(io::IO, node::Subscript) -> Nothing\n\nConvert subscript to LaTeX, writing to IO.\n\n\n\n\n\nto_latex(io::IO, node::Superscript) -> Nothing\n\nConvert superscript to LaTeX, writing to IO.\n\n\n\n\n\nto_latex(io::IO, node::Link) -> Nothing\n\nConvert a link to LaTeX (using hyperref), writing to IO.\n\n\n\n\n\nto_latex(io::IO, node::Image) -> Nothing\n\nConvert an image to LaTeX, writing to IO.\n\n\n\n\n\nto_latex(io::IO, node::CrossRef) -> Nothing\n\nConvert a cross-reference to LaTeX, writing to IO.\n\n\n\n\n\nto_latex(io::IO, node::LineBreak) -> Nothing\n\nConvert a line break to LaTeX, writing to IO.\n\n\n\n\n\nto_latex(io::IO, node::PassthroughBlock) -> Nothing\n\nConvert a passthrough block to LaTeX, writing to IO.\n\nIf the block has a \"stem\" style attribute, wraps it as display math. Otherwise, outputs raw content (useful for embedding raw LaTeX).\n\n\n\n\n\nto_latex(io::IO, node::InlineMath) -> Nothing\n\nConvert inline math to LaTeX, writing to IO.\n\nWraps content in inline math delimiters.\n\n\n\n\n\nto_latex(doc::Document) -> String\n\nConvert an AsciiDoc document to LaTeX string.\n\nThis is a convenience wrapper that creates an IOBuffer internally. For streaming output, use to_latex(io::IO, doc::Document) instead.\n\n\n\n\n\nto_latex(node::Union{BlockNode,InlineNode}) -> String\n\nConvert any AST node to LaTeX string.\n\nThis is a convenience wrapper that creates an IOBuffer internally. For streaming output, use to_latex(io::IO, node) instead.\n\n\n\n\n\n","category":"function"},{"location":"reference/#AsciiDocumenter.to_markdownast","page":"API Reference","title":"AsciiDocumenter.to_markdownast","text":"to_markdownast(doc::Document) -> MarkdownAST.Node\n\nConvert an AsciiDoc document to MarkdownAST representation.\n\nThis enables integration with Documenter.jl and other tools that consume MarkdownAST.\n\n\n\n\n\n","category":"function"},{"location":"reference/#AsciiDocumenter.to_markdown","page":"API Reference","title":"AsciiDocumenter.to_markdown","text":"to_markdown(doc::Document) -> String\n\nConvert an AsciiDoc document to a Markdown string.\n\nExample\n\ndoc = parse(\"\"\"\n= My Title\n\nSome *bold* text.\n\"\"\")\n\nmd = to_markdown(doc)\n\n\n\n\n\n","category":"function"},{"location":"reference/#AsciiDocumenter.Document","page":"API Reference","title":"AsciiDocumenter.Document","text":"Document(attributes::Dict{String,String}, blocks::Vector{BlockNode})\n\nRoot node representing a complete AsciiDoc document.\n\n\n\n\n\n","category":"type"},{"location":"reference/#AsciiDocumenter.Header","page":"API Reference","title":"AsciiDocumenter.Header","text":"Header(level::Int, text::Vector{InlineNode}, id::String)\n\nRepresents a section header (= to ======).\n\n\n\n\n\n","category":"type"},{"location":"reference/#AsciiDocumenter.Paragraph","page":"API Reference","title":"AsciiDocumenter.Paragraph","text":"Paragraph(content::Vector{InlineNode}, attributes::Dict{String,String})\n\nA paragraph of text with inline formatting.\n\n\n\n\n\n","category":"type"},{"location":"reference/#AsciiDocumenter.CodeBlock","page":"API Reference","title":"AsciiDocumenter.CodeBlock","text":"CodeBlock(content::String, language::String, attributes::Dict{String,String}, callouts::Dict{Int,String})\n\nA source code block with optional syntax highlighting.\n\nThe callouts dict maps callout numbers (1, 2, ...) to their explanatory text. Callouts are numbered markers like <1> in code that reference explanations.\n\n\n\n\n\n","category":"type"},{"location":"reference/#AsciiDocumenter.BlockQuote","page":"API Reference","title":"AsciiDocumenter.BlockQuote","text":"BlockQuote(blocks::Vector{BlockNode}, attribution::String)\n\nA block quotation, optionally with attribution.\n\n\n\n\n\n","category":"type"},{"location":"reference/#AsciiDocumenter.HorizontalRule","page":"API Reference","title":"AsciiDocumenter.HorizontalRule","text":"HorizontalRule(attributes::Dict{String,String})\n\nA horizontal rule ('''  or –-).\n\n\n\n\n\n","category":"type"},{"location":"reference/#AsciiDocumenter.UnorderedList","page":"API Reference","title":"AsciiDocumenter.UnorderedList","text":"UnorderedList(items::Vector{ListItem}, attributes::Dict{String,String})\n\nA bulleted list (* or -).\n\n\n\n\n\n","category":"type"},{"location":"reference/#AsciiDocumenter.OrderedList","page":"API Reference","title":"AsciiDocumenter.OrderedList","text":"OrderedList(items::Vector{ListItem}, style::String, attributes::Dict{String,String})\n\nA numbered list (. or 1.).\n\n\n\n\n\n","category":"type"},{"location":"reference/#AsciiDocumenter.DefinitionList","page":"API Reference","title":"AsciiDocumenter.DefinitionList","text":"DefinitionList(items::Vector{Tuple{DefinitionTerm,DefinitionDescription}})\n\nA definition list (term::).\n\n\n\n\n\n","category":"type"},{"location":"reference/#AsciiDocumenter.Table","page":"API Reference","title":"AsciiDocumenter.Table","text":"Table(rows::Vector{TableRow}, attributes::Dict{String,String})\n\nA table with rows and cells.\n\n\n\n\n\n","category":"type"},{"location":"reference/#AsciiDocumenter.Text","page":"API Reference","title":"AsciiDocumenter.Text","text":"Text(content::String)\n\nPlain text content.\n\n\n\n\n\n","category":"type"},{"location":"reference/#AsciiDocumenter.Bold","page":"API Reference","title":"AsciiDocumenter.Bold","text":"Bold(content::Vector{InlineNode})\n\nBold text (text).\n\n\n\n\n\n","category":"type"},{"location":"reference/#AsciiDocumenter.Italic","page":"API Reference","title":"AsciiDocumenter.Italic","text":"Italic(content::Vector{InlineNode})\n\nItalic text (text).\n\n\n\n\n\n","category":"type"},{"location":"reference/#AsciiDocumenter.Monospace","page":"API Reference","title":"AsciiDocumenter.Monospace","text":"Monospace(content::Vector{InlineNode})\n\nMonospace/code text (text).\n\n\n\n\n\n","category":"type"},{"location":"reference/#AsciiDocumenter.Link","page":"API Reference","title":"AsciiDocumenter.Link","text":"Link(url::String, text::Vector{InlineNode})\n\nA hyperlink.\n\n\n\n\n\n","category":"type"},{"location":"reference/#AsciiDocumenter.Image","page":"API Reference","title":"AsciiDocumenter.Image","text":"Image(url::String, alt_text::String, attributes::Dict{String,String})\n\nAn embedded image.\n\n\n\n\n\n","category":"type"},{"location":"reference/#AsciiDocumenter.CrossRef","page":"API Reference","title":"AsciiDocumenter.CrossRef","text":"CrossRef(target::String, text::Vector{InlineNode})\n\nA cross-reference to another section.\n\n\n\n\n\n","category":"type"},{"location":"#AsciiDocumenter.jl","page":"Home","title":"AsciiDocumenter.jl","text":"Convert AsciiDoc to Markdown for use with Documenter.jl.","category":"section"},{"location":"#Quick-Start","page":"Home","title":"Quick Start","text":"using Pkg\nPkg.add(\"AsciiDocumenter\")\n\nusing AsciiDocumenter\n\n# Parse AsciiDoc\ndoc = AsciiDocumenter.parse(\"\"\"\n= My Document\n\nThis is *bold* text.\n\nSee link:@ref[My Function].\n\"\"\")\n\n# Convert to Markdown string for Documenter\nmd = AsciiDocumenter.to_markdown(doc)","category":"section"},{"location":"#Documentation","page":"Home","title":"Documentation","text":"Guide — How to configure make.jl and project structure.\nSyntax — How to write AsciiDoc that maps to Documenter features (math, cross-refs, @docs).","category":"section"},{"location":"#Supported-Features","page":"Home","title":"Supported Features","text":"Feature AsciiDoc Syntax Documenter Result\nCross-Refs link:@ref[Target] [Target](@ref)\nMath stem:[x^2] $x^2$\nDocstrings [source,@docs] docs\nAdmonitions [NOTE] !!! note\nCode [source,julia] julia\nStandard Headers, Lists, Tables Standard Markdown","category":"section"},{"location":"#License","page":"Home","title":"License","text":"MIT","category":"section"},{"location":"syntax/#AsciiDoc-Syntax-for-Documenter.jl","page":"Syntax","title":"AsciiDoc Syntax for Documenter.jl","text":"This guide covers how to write AsciiDoc that compiles correctly to Documenter.jl's expected format.","category":"section"},{"location":"syntax/#Documenter-Features","page":"Syntax","title":"Documenter Features","text":"","category":"section"},{"location":"syntax/#Cross-References-(@ref)","page":"Syntax","title":"Cross-References (@ref)","text":"Use the link: macro to create Documenter-style cross-references. This macro allows any target string, enabling @ref syntax.\n\n// Link to a docstring\nSee the link:@ref[MyFunction] documentation.\n\n// Link to a section in another file\nSee link:@ref[Section Name] for details.\n\n// Explicit @ref syntax\nSee link:@ref#my-id[Custom Link Text].\n\n// Relative links to other files\nSee the link:../guide.md[User Guide].","category":"section"},{"location":"syntax/#Math","page":"Syntax","title":"Math","text":"AsciiDocumenter.jl supports stem (Science, Technology, Engineering, Math) blocks, which map directly to Documenter's math support.\n\nInline Math:\n\nThe formula is stem:[E = mc^2].\n\nDisplay Math:\n\n[stem]\n++++\n\\int_0^\\infty x^2 dx\n++++","category":"section"},{"location":"syntax/#Documenter-Blocks-(@docs,-@example,-etc.)","page":"Syntax","title":"Documenter Blocks (@docs, @example, etc.)","text":"To use Documenter's \"magic\" blocks like @docs, @example, or @repl, use a source block with the language prefixed by @.\n\n@docs (Docstrings):\n\n[source,@docs]\n\nMyPackage.my_function\n\n\n\n@example (Executed Code):\n\n[source,@example]\n\nx = 10 y = 20 println(x + y)\n\n\n\n@repl (REPL Simulation):\n\n[source,@repl]\n\njulia> 1 + 1 2\n\n","category":"section"},{"location":"syntax/#Standard-AsciiDoc-Syntax","page":"Syntax","title":"Standard AsciiDoc Syntax","text":"","category":"section"},{"location":"syntax/#Headings","page":"Syntax","title":"Headings","text":"= Document Title (H1)\n== Section Level 2\n=== Section Level 3\n==== Section Level 4","category":"section"},{"location":"syntax/#Text-Formatting","page":"Syntax","title":"Text Formatting","text":"*Bold text*\n_Italic text_\n`Monospace/Code`\n#Subscript# (Coming soon)\n^Superscript^ (Coming soon)","category":"section"},{"location":"syntax/#Lists","page":"Syntax","title":"Lists","text":"Unordered:\n\n* Item 1\n* Item 2\n** Nested Item\n\nOrdered:\n\n. Step 1\n. Step 2\n.. Nested Step\n\nDefinition Lists:\n\nTerm 1:: Definition text\nTerm 2:: \n+\nMulti-paragraph definition.","category":"section"},{"location":"syntax/#Code-Blocks","page":"Syntax","title":"Code Blocks","text":"Standard code blocks map to Markdown code fences.\n\n[source,julia]\n\nfunction foo()     return \"bar\" end\n\n","category":"section"},{"location":"syntax/#Admonitions","page":"Syntax","title":"Admonitions","text":"Maps standard AsciiDoc admonitions to Documenter's !!! blocks.\n\n[NOTE]\n.Optional Title\n====\nThis is a note block.\n====\n\nWARNING: This is a single-line warning.\n\nSupported types: NOTE, TIP, WARNING, IMPORTANT, CAUTION.","category":"section"},{"location":"syntax/#Tables","page":"Syntax","title":"Tables","text":"Standard AsciiDoc tables are supported.\n\n|===\n| Header 1 | Header 2\n\n| Cell A1  | Cell A2\n| Cell B1  | Cell B2\n|===","category":"section"},{"location":"syntax/#Images","page":"Syntax","title":"Images","text":"image::path/to/image.png[Alt Text]","category":"section"},{"location":"syntax/#Raw-Passthrough","page":"Syntax","title":"Raw Passthrough","text":"To inject raw HTML or content that should bypass processing:\n\n++++\n<div class=\"custom-alert\">\n  Raw HTML content\n</div>\n++++","category":"section"}]
}
